{
  "name": "light-map",
  "version": "0.0.2",
  "description": "a light-weight TMS viewer",
  "main": "bin/light-map.js",
  "scripts": {
    "test": "new Map( provider, domains, 512,512, 0,10 )"

  },
  "keywords": [
    "map",
    "maps",
    "tms",
    "WGS84",
    "canvas",
    "self-contained",
    "mercator"
  ],
  "author": "Nicolas Barradeau",
  "maintainers": [
    {
      "name": "Nicolas Barradeau",
      "email": "nicoptere@gmail.com",
      "web": "http://www.barradeau.com/blog"
    }
  ],

  "devDependencies": {
    "uglifyjs": "^2.4.10"
  },

  "scripts": {
    "bundle": "browserify map/Map.js --standalone Map -o bin/light-map.js",
    "uglify": "uglifyjs bin/light-map.js -m -c -screw-ie8 > example/light-map.min.js",
    "build": "npm run bundle && npm run uglify"
  },

  "demos": [
    "./example/index.html"
  ],

  "readme": "light map\n=============\n\nminimal, lightweight, self contained TMS viewer with a 2d canvas renderer.\n\n### Installation ###\n```\nnpm install light-map --save\n```\n\n### Basic Usage Example ###\n\n```js\n<script src=\"light-map.min.js\"></script>\n\n<script>\n\n\n    // provider: URL of the tile map service\n    // domains: URL of the domains used by the tile map service\n    // you can choose from a list of *free* TMS providers:\n    // http://leaflet-extras.github.io/leaflet-providers/preview/\n    // example:\n    //\n    //        provider = \"http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\";\n    //        domains = [ \"a\", \"b\", \"c\" ];\n    //\n    //alternately you can use mbtiles\n\n    var provider, domains;\n    provider = \"http://ttiles{s}.mqcdn.com/tiles/1.0.0/vy/sat/{z}/{x}/{y}.png\";\n    domains = [ \"01\" , \"02\", \"03\", \"04\" ];\n\n\n    // we often need to use a proxy to load images on local servers\n    // check out this gist : https://gist.github.com/nicoptere/a23ffae9ed51a5ca9766\n    var proxy = \"./proxy.php?url=\";\n\n    var map = new Map( proxy + provider, domains, 512,512, 0, 10 );\n    document.body.appendChild( map.canvas );\n\n\n    //listening to the loading events\n\n    //all tiles were loaded\n    function onLoadComplete( status )\n    {\n        if(status==0 )\n        {\n            console.log( \"onLoadComplete\", \"->\", status );\n        }\n    }\n\n    //a new tile was loaded here\n    function onTileLoaded( tile )\n    {\n        console.log( \"onTileLoaded\", \"->\", tile );\n    }\n\n    //the canvas' context is returned here\n    function onTextureUpdate( ctx )\n    {\n        console.log( \"onTextureUpdate\" );\n    }\n\n    map.eventEmitter.on( Map.ON_LOAD_COMPLETE, onLoadComplete );\n    map.eventEmitter.on( Map.ON_TILE_LOADED, onTileLoaded );\n    map.eventEmitter.on( Map.ON_TEXTURE_UPDATE, onTextureUpdate );\n\n\n    //this would be where I live :)\n    var lat = o_lat = 48.854777;\n    var lon = o_lon = 2.317499;\n    var zoom = 16;\n    map.setView( lat, lon, zoom );\n\n    //it can be done in a loop\n    function update(){\n\n        var t = ( Math.sin( Date.now() * 0.001 ) );\n\n        lat = o_lat;\n        lon = o_lon + t * .0025;\n\n        map.setView( lat, lon, zoom );\n\n    }\n    setInterval( update, 1000 / 60 );\n\n    // and as the result is a canvas, it's possible\n    // to add post processing to map.ctx\n    ///*\n\n    function postProcess( ctx )\n    {\n\n        /*\n        //adding grain: computationnaly expensive, avoid in loops\n        var imgData = ctx.getImageData(0,0,map.width, map.height );\n        var data = imgData.data;\n\n        var noise = 100;\n        for( var i = 0; i < data.length; i+= 4 )\n        {\n            var grain = ~~( (.5 - Math.random() ) * 2 * noise );\n            data[ i ]       += grain;\n            data[ i + 1 ]   += grain;\n            data[ i + 2 ]   += grain;\n        }\n        imgData.data = data;\n        ctx.putImageData( imgData, 0,0 );\n        //*/\n\n        //create a vignette\n        var w2 = map.width / 2;\n        var grd = ctx.createRadialGradient( w2, w2, 0.000, w2, w2, w2);\n\n        // Add colors\n        grd.addColorStop(0.000, 'rgba(0, 0, 0, 0.00 )');\n        grd.addColorStop(1.000, 'rgba(0, 0, 0, 0.75 )');\n\n        // Fill with gradient\n        ctx.fillStyle = grd;\n        ctx.fillRect(0, 0, map.width, map.height );\n\n    }\n    map.eventEmitter.on( Map.ON_TEXTURE_UPDATE, postProcess );\n\n\n</script>\n\n```\nit should look like this:<br>\n<img src=\"https://github.com/nicoptere/light-map/blob/master/example/light-map.jpg\">\n\n### additional information ###\n\n[Python library to perform Mercator conversions](http://www.maptiler.org/google-maps-coordinates-tile-bounds-projection/)\n\n[Quad keys explained](https://msdn.microsoft.com/en-us/library/bb259689.aspx)\n\n### related ###\nnpm [globalMercator](https://github.com/davvo/globalmercator/blob/master/globalmercator.js)\n\n### Test ###\n\n### License ###\n\nThis content is released under the [MIT License](http://opensource.org/licenses/MIT).",

  "repository": {
    "type": "git",
    "url": "https://github.com/nicoptere/light-map.git"
  },
  "license": "MIT",

  "bugs": {
    "url": "https://github.com/nicoptere/light-map/issues"
  },

  "homepage": "https://github.com/nicoptere/light-map"
}
